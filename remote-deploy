#!/bin/bash

GIT_VERSION=HEAD

shopt -s nullglob

# Version check
if [ "x$1" != "x$GIT_VERSION" ]; then
	echo "Error : Version mismatch"
	echo "Local : $1"
	echo "Remote: $GIT_VERSION"
	echo "Aborted, upgrade the remote version with 'install remote'"
	exit 1
fi

shift

deploy_container() {
	local domain=$1
	local app=$2
	local image=$3
	local port=$(find_free_port)

	[[ $image == - ]] && image=$(get_metadata $domain $app image)

	if [ "x$(app_in_dns $app $domain)" == xtrue ]; then
		mkdir -p /tmp/docker/$domain/$app

		# Generate enviroment
		local env_list
		for env in /tmp/docker/$domain/$app/ENV_*; do
			if [ -f $env ]; then
				env_list="$env_list -e $(basename ${env:4})=\"$(cat $env)\" ";
			fi
		done

		# Generate port forwards
		local port_list
		for p in /tmp/docker/$domain/$app/port[0-9]*; do
			if [ -f $p ]; then
				local p1=$(basename $p)
				local p2=$(cat $p)
				port_list="$port_list -p $p2:${p1:4} ";

				# Is the port in use?
				if netstat -ntap | grep -q $p2; then
					echo "Port $p2 is already in use, the old container will be undeployed before"
					echo "the deploy. This will cause a short service interruption."
					stop_container $domain $app $port
				fi
			fi
		done

		local http_port=80;
		if has_metadata $domain $app http-port; then
			http_port=$(get_metadata $domain $app http-port)
		fi

		echo -e "Deploying \e[1m$app.$domain\e[0m ($image):$http_port â‡„ $port"
		echo -e "Extra: $env_list $port_list"
		local app_id=$(docker run -d -p 127.0.0.1:$port:$http_port $env_list $port_list \
			--name app-$domain-$app-$port-$RANDOM $image)

		configure_nginx $domain $app $port
		save_metadata $domain $app id $app_id
		save_metadata $domain $app app $app
		save_metadata $domain $app port $port
		save_metadata $domain $app image $image
		save_metadata $domain $app domain $domain
	fi

	stop_container $domain $app $port
}

stop_container() {
	local domain=$1
	local app=$2
	local port=$3

	for id in $(docker ps --no-trunc | grep -v :$port | grep app-${domain}-${app}- | awk '{print $1}'); do
		echo "Stop container id:$id"
		docker stop $id > /dev/null
	done
}

undeploy_container() {
	local domain=$1
	local app=$2

	if [ x$(has_app $domain $app) == xyes ]; then
		echo -e "\e[1mUndeploy $app.$domain\e[0m"
		docker stop $(cat /tmp/docker/$domain/$app/id)
		rm -f /etc/nginx/conf.d/${domain}-${app}.conf
		nginx -s reload
		rm -f /tmp/docker/$domain/$app/id
	fi

}

remove_app() {
	local domain=$1
	local app=$2

	[ ! -d /tmp/docker/$domain/$app ] && return 1

	undeploy_container $domain $app
	echo "Remove $app.$domain"
	rm -rf /tmp/docker/$domain/$app
	if [ ! -d /tmp/docker/$domain/* ]; then
		echo "Remove $domain"
		rmdir /tmp/docker/$domain
	fi
}

has_app() {
	local domain=$1
	local chapp=$2

	for uid in $(docker ps --no-trunc -q); do
		local app=$(get_app_from_id_with_domain $domain $uid)
		if [ x$app == x$chapp ]; then
			echo yes
			return;
		fi
	done
}

get_app_from_id_with_domain() {
	local domain=$1
	local uid=$2

	local path=$(echo /tmp/docker/$domain/*/id)
	[ ! -z $path ] && grep -l $uid $path | awk -F'/' '{print $5}'
}

get_domain_app_from_id() {
	local uid=$1

	local path=$(grep -l $uid /tmp/docker/*/*/id)
	path=${path%/id}

	echo $(cat $path/domain) $(cat $path/app)
}

configure_nginx() {
	local domain=$1
	local app=$2
	local port=$3
	
	if [ $(get_metadata $domain $app default) ]; then
		listen="80 default";
	else
		listen=80;
	fi

	echo "
	server {
		listen $listen;
		server_name ${app}.$domain;
		location / {
			proxy_pass http://127.0.0.1:$port;
		}
	}
	" > /etc/nginx/conf.d/${domain}-${app}.conf
	nginx -s reload
}

save_metadata() {
	local domain=$1
	local app=$2
	local key=$3
	local value=$4

	mkdir -p /tmp/docker/$domain/$app
	if [ "x$value" == "xfalse" ]; then
		rm /tmp/docker/$domain/$app/$key
	else
		echo $value > /tmp/docker/$domain/$app/$key
	fi
}

get_metadata() {
	local domain=$1
	local app=$2
	local key=$3

	[ -f /tmp/docker/$domain/$app/$key ] && cat /tmp/docker/$domain/$app/$key
}

has_metadata() {
	local domain=$1
	local app=$2
	local key=$3

	[ -f /tmp/docker/$domain/$app/$key ] && return 0
	return 1
}

find_free_port() {
	for port in $(seq 30000 39999); do
		if ! netstat -nta | grep -q $port; then
			echo $port;
			break;
		fi;
	done
}

app_in_dns() {
	local app=$1
	local domain=$2

	for record in A AAAA; do
		for ip in $(dig +short $record $app.$domain); do
			if ip addr | grep -qi $ip; then
				echo true
				return
			fi
		done
	done
}

setup_host() {
	check_release

	export DEBIAN_FRONTEND=noninteractive

	# Setup docker repo
	apt-key adv \
		--keyserver hkp://keyserver.ubuntu.com:80 \
		--recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9
	echo deb https://get.docker.com/ubuntu docker main > /etc/apt/sources.list.d/docker.list

	# Setup gluster repo
	wget -O /tmp/glusterfs.key \
		http://download.gluster.org/pub/gluster/glusterfs/3.6/LATEST/Debian/wheezy/pubkey.gpg
	echo "d903892dfe9afa0be141f27fd1c1889f770b4e8d  /tmp/glusterfs.key" | sha1sum -c - || exit 1
		apt-key add /tmp/glusterfs.key
	    echo "deb [arch=amd64] http://download.gluster.org/pub/gluster/glusterfs/3.6/3.6.1/Debian/wheezy/apt wheezy main" > /etc/apt/sources.list.d/glusterfs.list

	# Update repos
	apt-get update

	# Install packages
	apt-get install -y lxc-docker nginx glusterfs-server attr iptables-persistent

	# nginx config
	rm -f /etc/nginx/sites-available/* /etc/nginx/sites-enabled/*
	open_port tcp 80

	# Detect default interface for ipv4 and ipv6
	local ifv4=$(ip -4 route get 8.8.8.8 | grep dev | sed 's/.*dev \([^ ]*\).*/\1/')
	local ifv6=$(ip -6 route get 2001:4860:4860::8888 | grep dev | sed 's/.*dev \([^ ]*\).*/\1/')

	if [ -z $ifv4 ] && [ -z $ifv6 ]; then
		echo "Error, no IPv4 or IPv6 interfaces found."
		echo "Install aborted"
		exit 1
	fi

	# Configure firewall for IPv4
	if [[ $ifv4 != lo ]] && [ ! -z $ifv4 ]; then
		echo "Host has IPv4: Default IPv4 interface is $ifv4"

		# Drop all packages from the internet
		firewall_rule 4 -P INPUT   DROP
		firewall_rule 4 -P FORWARD DROP
		firewall_rule 4 -P OUTPUT  ACCEPT

		# Allow traffic on local if
		firewall_rule 4 -A INPUT  -i lo -j ACCEPT
		firewall_rule 4 -A OUTPUT -o lo -j ACCEPT

		# Allow traffic on other networks
		firewall_rule 4 -A INPUT  ! -i $ifv4 -j ACCEPT

		# Accept
		firewall_rule 4 -A INPUT -i $ifv4 -m state --state ESTABLISHED,RELATED -j ACCEPT
		firewall_rule 4 -A INPUT -i $ifv4 -p icmp -m limit --limit 10/second -j ACCEPT

		# Limit SSH access
		firewall_rule 4 -A INPUT -p tcp --dport 22 -m recent --update --seconds 60 \
			--hitcount 15 --name SSH -j DROP
		firewall_rule 4 -A INPUT -p tcp --dport 22 -m state --state NEW -m recent \
			--set --name SSH -j ACCEPT
	fi

	# Configure firewall for IPv6
	if [[ $ifv6 != lo ]] && [ ! -z $ifv6 ]; then
		echo "Host has IPv6: Default IPv6 interface is $ifv6"

		# Drop all packages from the internet
		firewall_rule 6 -P INPUT   DROP
		firewall_rule 6 -P FORWARD DROP
		firewall_rule 6 -P OUTPUT  ACCEPT

		# Allow traffic on local if
		firewall_rule 6 -A INPUT  -i lo -j ACCEPT
		firewall_rule 6 -A OUTPUT -o lo -j ACCEPT

		# Allow traffic on other networks
		firewall_rule 4 -A INPUT  ! -i $ifv6 -j ACCEPT

		# Accept
		firewall_rule 6 -A INPUT -i $ifv6 -m state --state ESTABLISHED,RELATED -j ACCEPT
		firewall_rule 6 -A INPUT -i $ifv6 -p icmp -m limit --limit 10/second -j ACCEPT

		# Limit SSH access
		firewall_rule 6 -A INPUT -p tcp --dport 22 -m recent --update --seconds 60 \
			--hitcount 15 --name SSH -j DROP
		firewall_rule 6 -A INPUT -p tcp --dport 22 -m state --state NEW -m recent \
			--set --name SSH -j ACCEPT
	fi

	save_firewall

	# Download docker-gc from Spotify
	if [ ! -f /etc/cron.hourly/docker-gc ]; then
		echo "Download docker-gc from Spotify"
		curl -L https://raw.githubusercontent.com/spotify/docker-gc/1b5d533172fa3707dcd4e5a4a3b7cd25d6e6e237/docker-gc -o /tmp/docker-gc
		echo "512be3310ab699b9ff414bc4026553a32eab31af  /tmp/docker-gc" | sha1sum -c - || exit 1
		mv /tmp/docker-gc /etc/cron.hourly/docker-gc
		chmod +x /etc/cron.hourly/docker-gc
	fi

}

setup_gluster_share() {
	local num_vpn_nodes=1
	local bricks=

	# Use the ARP table to detect the other hosts.
	for ip in $(arp -an -H ether | awk '/on vpn/{print $2}' | tr -d '()'); do
		num_vpn_nodes=$(( $num_vpn_nodes + 1 ))
		bricks="$bricks $ip:/share"
		if ! gluster peer status | awk '/Hostname/{print $NF}' | grep -q $ip; then
			echo "Add Gluster peer $ip"
			gluster peer probe $ip
		fi
	done

	# Make sure we have the shared path
	mkdir -p /share

	for ip in $(hostname -I); do
		if [[ $ip == '10.10.0.1' ]]; then
			bricks="$ip:/share $bricks"
			local num_bricks=$(gluster volume info share | awk '/Number of Bricks/{print $NF}')
			echo "This is VPN host 10.10.0.1, we have $num_vpn_nodes bricks in the cluster."
			if [[ $num_bricks != $num_vpn_nodes ]]; then

				# Bricks do not match VPN nodes, try to change that
				if [ $num_vpn_nodes -gt $num_bricks ]; then
					echo "Number of bricks/replica need to be increased to $num_vpn_nodes"
					echo gluster volume add-brick share replica $num_vpn_nodes 
				else
					echo "We need to decrease number of bricks to $num_vpn_nodes"
					echo "NOT implemented"
					exit 1
				fi

#				gluster volume create share replica $num_vpn_nodes \
#					transport tcp $bricks force
#				gluster volume start share


			fi
		fi
	done
}

save_firewall() {
	iptables-save > /etc/iptables/rules.v4
	ip6tables-save > /etc/iptables/rules.v6
}

firewall_rule() {
	local version=$1
	local flag=$2
	shift 2
	if [[ $version == 4 ]]; then
		iptables  -C $@ 2> /dev/null || ( 
			[[ $flag != -P ]] && set -x
			iptables  $flag $@
		)
	else
		ip6tables -C $@ 2> /dev/null || (
			[[ $flag != -P ]] && set -x
			ip6tables $flag $@
		)
	fi
}

remove_port_rule() {
	local proto=$1
	local port=$2

	if has_ipv4; then
		local host4=$(ip -4 route get 8.8.8.8 | awk '/src/{print $NF}')
		while iptables -D INPUT -p $proto --dport $port -d $host4 -j DROP 2> /dev/null; do
			echo "Remove INPUT FW rule for $proto:$port for ipv4"
		done
		while iptables -D FORWARD -p $proto --dport $port -d $host4 -j DROP 2> /dev/null; do
			echo "Remove FORWARD FW rule for $proto:$port for ipv4"
		done
	fi

	if has_ipv6; then
		local host6=$(ip -6 route get 2001:4860:4860::8888 | awk '/src/{print $NF}')
		while ip6tables -D INPUT -p $proto --dport $port -d $host6 -j DROP 2> /dev/null; do
			echo "Remove INPUT FW rule for $proto:$port for ipv6"
		done
		while ip6tables -D FORWARD -p $proto --dport $port -d $host6 -j DROP 2> /dev/null; do
			echo "Remove FORWARD FW rule for $proto:$port for ipv6"
		done
	fi

	save_firewall
}

open_port() {
	local proto=$1
	local port=$2

	if has_ipv4; then
		local ifv4=$(ip -4 route get 8.8.8.8 | grep dev | sed 's/.*dev \([^ ]*\).*/\1/')
		firewall_rule 4 -I INPUT -p $proto --dport $port -i $ifv4 -j ACCEPT
	fi

	if has_ipv6; then
		local ifv6=$(ip -6 route get 2001:4860:4860::8888 | grep dev | sed 's/.*dev \([^ ]*\).*/\1/')
		firewall_rule 6 -I INPUT -p $proto --dport $port -i $ifv6 -j ACCEPT
	fi

	save_firewall
}

has_ipv4() {
	if ip -4 route get 8.8.8.8 | grep -q unreachable; then
		return 1
	fi
	return 0
}

has_ipv6() {
	if ip -6 route get 2001:4860:4860::8888 | grep -q unreachable; then
		return 1
	fi
	return 0
}

check_release() {
	local version=$(lsb_release -rs)

	# Make sure this is a supported version
	case $version in
		14.04)
			echo "Detected Ubuntu $version LTS, supported!"
			;;
		*)
			echo "Detected $version, not supported."
			echo "Aborted!"
			exit 1
			;;
	esac
}

array_has_element() {
	local elem
	for elem in "${@:2}"; do
		if [ "x$elem" == "x$1" ]; then
			return 0
		fi
	done
	return 1
}

check_for_dns() {
	local domain=$1
	local app=$2

	for record in A AAAA; do
		for ip in $(dig +short $record $app.$domain); do
			if ip addr | grep -qi $ip; then
				echo -n " [DNS:$record]"
			fi
		done
	done
}

has_apps() {
	for f in /tmp/docker/*; do
		[ -d $f ] && return 0
	done
	return 1
}

list_apps() {
	has_apps || exit 0

	declare -a containers

	for uid in $(docker ps --no-trunc -q); do
		local domain_app=$(get_domain_app_from_id $uid)

		local domain=$(echo $domain_app | awk '{print $1}')
		local app=$(echo $domain_app | awk '{print $2}')
		local port=$(get_metadata $domain $app port)
		local image=$(get_metadata $domain $app image)
		local default=$(get_metadata $domain $app default)
		local http_port=80;
		if has_metadata $domain $app http-port; then
			http_port=$(get_metadata $domain $app http-port)
		fi

		containers+=($app.$domain)

		echo -n "$app.$domain ($image):$http_port â‡„ $port"

		# Is this the default container
		if [ $default ]; then
			echo -n " [default]"
		fi

		# DNS lookup
		check_for_dns $domain $app

		echo # newline

		for p in /tmp/docker/$domain/$app/port[0-9]*; do
			if [ -f $p ]; then
				local p1=$(basename $p)
				local p2=$(cat $p)
				echo -e " â†³ forwarded port ${p1:4} â‡„ $p2"
			fi
		done

	done

	for domain in /tmp/docker/*; do
		for app in $domain/*; do
			local atest=${app##*/}.${domain##*/}
			if ! array_has_element $atest "${containers[@]}"; then
				echo -n "$atest [not deployed]"
		
				# DNS lookup
				check_for_dns ${domain##*/} ${app##*/}

				echo # newline
			fi
		done
	done

}

show_status() {
	local ch=$1

	if [[ $ch == "fs" ]]; then
		echo -e "\n\e[4mGluster peers\e[0m"
		gluster peer status | cat -
		echo
		echo -e "\n\e[4mGluster volumes\e[0m"
		gluster volume status | cat -
		echo
		echo -e "\e[4mContainer disk usage\e[0m"
		df -h /var/lib/docker/ --output="ipcent,pcent" | \
			tail -1 | awk '{ print "inodes "$1" bytes "$2 }'
	elif [[ $ch == "vpn" ]]; then
		echo -e "\n\e[4mVPN device statics\e[0m"
		ip addr show dev vpn

		echo -e "\e[4mVPN status\e[0m"
		local pid=$(pgrep tincd)
		kill -USR2 $pid
		kill -USR1 $pid
		grep $(date +%H:%M) /var/log/syslog \
			| grep "vpn\[$pid\]" \
			| sed "s/.*tinc\.vpn\[$pid\]: //"
	fi
}

case $1 in
	deploy)
		deploy_container $2 $3 $4 $5
		;;
	undeploy)
		undeploy_container $2 $3
		;;
	remove)
		remove_app $2 $3
		;;
	setup)
		setup_host
		;;
	list)
		list_apps
		;;
	save-metadata)
		save_metadata $2 $3 $4 $5
		;;
	get-metadata)
		get_metadata $2 $3 $4
		;;
	status)
		show_status $2
		;;
	openport)
		open_port $2 $3
		;;
	waitfor)
		while true; do sleep 1; done
		;;
	version)
		echo $GIT_VERSION
		;;
esac
